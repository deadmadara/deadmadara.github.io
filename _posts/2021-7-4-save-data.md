---
layout: post
title: Хранение данных (файл, XML, JSON, SQL)
comments: true
published: true
---
Краткий обзор форматов на конкретном примере.

Недавно мне выдалось поиграть в настольную RPG Pathfinder. Как и все подобные игры, она снабжается талмудом с правилами для игрока, мастера, а также карточками персонажа. Выглядят они примерно вот [так](https://github.com/deadmadara/deadmadara.github.io/blob/main/images/pathfinder-char-list.png?raw=true). Помимо имени и значений навыков в них также отражены текущий опыт, снаряжение и прочие аттрибуты персонажа. Т.к. найти программу с лаконичным интерфейсом и русским языком мне не удалось, возникла идея написать небольшое приложение, которое позволяло бы загружать в форму данные, а затем во время очередной игровой сессии их считывать и менять по ходу. Получить данные из формы и передать их в объект класса не проблема, но как их сохранить?..

**Сериализация** - сохранение объекта в виде последовательности байт, по которым можно будет восстановить исходный объект (в формате текста, XML, JSON и т.д.).

**Десериализация** - обратный процесс, восстановление объекта из последовательности байт.

Итак, допустим, создан класс *Player* с полями *Name*, *Race*, *Class*, *Level* и т.д.

1) **Файл** - стандартный текстовый файл .txt. Формально можно заносить значения, разделяя их спец. символом; обратно считывать из файла как большую строку, разбивать элементы по разделителям. Подход кривой, т.к. данные не структурированны, тип данных не указан, есть большая вероятность ошибки - например, какой-то параметр останется пустым, и произойдёт смещение. Для работы достаточно текстового редактора. 

**Формат**: Dead Madara; Human; Programmer; 0; 1 

2) **XML** - расширенный язык разметки; в отличие от HTML определяет синтаксис, а не саму разметку, т.е. можно лепить какие угодно теги. Имеет иерархическую структуру; состоит из тегов - открывающего и закрывающего, информация помещается между ними; корневой тег обязателен; в начале файла указывается версия xml и кодировка текста. Теги могут иметь аттрибуты со значениями. Может сопровождаться файлом XSD, регламентирующим теги для проверки соответствия. Для работы достаточно текстового редактора. 

**Формат**: В первом случае сами теги указывают на то, какое поле было сохранено.  
![]({{site.baseurl}}/images/xml1.png)  
Во втором случае - аттрибут name (*прим.: например, если заранее количество заполненных полей неизвестно*).  
![]({{site.baseurl}}/images/xml2.png)

3) **JSON** - изначально нотация объектов JavaScript, вообще текстовый формат обмена данными. Данные хранятся в формате пар ключ-значение (*прим.: как в ассоциативном массиве / словаре*); ключ является строкой в двойных кавычках, значением могут выступать запись, массив, число, литерал true/false/null, строка; пары разделяются запятыми; массивы указываются через []. Также поддерживает иерархию, т.е. внутри объекта может храниться дргуой объект, как и в XML. Считается более удобоваримым с точки зрения восприятия пользователем, чем XML. Для работы достаточно текстового редактора. 

**Формат**:  
![]({{site.baseurl}}/images/json.png)

4) **SQL** - язык структурированных запросов для работы с базами данных. Обычно БД представляют собой таблицы. SQL позволяет *модифицировать* данные, а не просто их складировать. В отличие от предыдущих способов хранения, может иметь хоть какую-то защиту данных. Для работы необходима система управления базой данных (СУБД) - например, Microsoft SQL Server Management Studio (*прим.: есть менее громоздкое ПО - SQLite*). 

**Формат**:   
![]({{site.baseurl}}/images/db1.png)   
![]({{site.baseurl}}/images/db2.png)

Итог: в идеале в данном случае следует использовать SQL хотя бы из принципа **расширяемости**, ведь, возможно, в дальнейшем в приложение захочется добавить базу знаний из предметов, чтобы не писать их вручную, и другие подобные фишки. 
На данный момент цель - реализовать хранение во всех форматах на тестовом примере, в дальнейшем приступить непосредственно к проекту.
