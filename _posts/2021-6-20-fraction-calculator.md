---
layout: post
title: Создание калькулятора (WF, C#)
comments: true
published: true
---
Но не простого, а дробного.

Основное отличие от обычного калькулятора – это использование в качестве объектов дробей в формате “a/b”. 
Для этого был создан класс **Fraction** с двумя полями – top и bottom для отображения числителя и знаменателя соответственно, а также два конструктора для создания объекта из **строки формата “a/b”** и чисел с проверкой на введённые нули (прим.: на лишние пробелы при вводе программа будет реагировать нормально, но вот на лишние символы нет, для этого нужно обрабатывать строку не командой Split(), а считывать посимвольно, выкидывая лишнее).

Методы:
* Сложение

* Вычитание

* Умножение

* Деление

* Сокращение

* Перевод дроби в формат строки

* Обработка примера в формате “a/b+c/d”

Арифметические функции реализованы в соответствии с правилами математики без сокращения результата; 
сокращение дроби реализовано по алгоритму Евклида; 
обработка примера проходит в несколько этапов: проверка на пустую строку (проблема неправильного формата всё ещё актуальна), разбиение примера на две дроби, считывание знака, проведение операции по знаку, сокращение. 

Интерфейс максимально прост (всё ещё не понимаю наличие цифр и знаков в стандартных калькуляторах):

![]({{site.baseurl}}/images/fractioncalc.png)

С помощью установки одинаковых значений в свойствах формы Maximum и Minimum Size достигнут фиксированный размер формы. Для удобства работы кнопки переименованы (по умолчанию выставляется button1, button2 и т.д.). 

Вся логики работы калькулятора выведена за код формы для **модульности**. 
При загрузке формы создаётся пустая дробь для доступа к методу-обработчику; 
при нажатии на “=” текст из поля отсылается в обработчик; при нажатии на “С” поле заполняется пустой строкой; 
при нажатии на “?” выводится окошко с сообщением о работе программы.

Исходный код и билд [тут](https://github.com/deadmadara/SimpleFractionCalculator).

Изначальная задумка включала в себе калькулятор **n дробей** одновременно в формате “a/b+c/d*e/f”. Кажется, для этого достаточно в методе handle() инициализировать дроби в цикле, сохранить операции в отдельном массиве и последовательно их проводить. Но есть одна проблема: **приоритетность** операций. Так что либо заставлять пользователя вводить операции в том порядке, в котором они должны проходить (что попросту неудобно), либо реализовывать **алгоритм сортировочной станции** с посимвольной обработкой и занесением операций в стек. 

